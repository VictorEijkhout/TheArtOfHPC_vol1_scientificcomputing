% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of 
%%%% `The Art of HPC, vol 1: The Science of Computing'
%%%% by Victor Eijkhout, copyright 2012-2023
%%%%
%%%% This book is distributed under a Creative Commons Attribution 3.0
%%%% Unported (CC BY 3.0) license and made possible by funding from
%%%% The Saylor Foundation \url{http://www.saylor.org}.
%%%%
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{language=bash}

Unix is an \indexacf{OS}, that is, a layer of software
between the user or a user program and the hardware. It takes care of
files and screen output, and it makes sure that many processes can exist
side by side on one system. However, it is not immediately visible to
the user.

Most of this tutorial will work on any Unix-like platform,
however, there is not just one Unix:
\begin{itemize}
\item Traditionally there are a few major flavors of Unix: ATT and BSD.
  Apple has Darwin which is close to BSD; IBM and HP have their own
  versions of Unix, and Linux is yet another variant. The differences between
  these are deep down and if you are taking this tutorial you probably
  won't see them for quite a while.
\item Within Linux there are various \indextermbus{Linux}{distributions}
  such as \indexterm{Red Hat} or \indexterm{Ubuntu}. These mainly differ
  in the organization of system files and again you probably need not worry
  about them.
\item The issue of command shells will be discussed below.
  This actually forms the most visible difference between different
  computers `running Unix'.
\end{itemize}

%\secttoc

\Level 0 {Shells}

Most of the time that you use Unix, you are typing commands which are
executed by an interpreter called the \indexterm{shell}. The shell
makes the actual \ac{OS} calls. There are a few possible Unix shells
available
\begin{itemize}
\item Most of this tutorial is focused on the
  \indexunix{sh} or \indexunix{bash} shell.
\item For a variety of reasons (see for instance section~\ref{sec:make-shell}),
  \n{bash}-like shells are to be preferred over the
  \indexunix{csh} or \indexunix{tcsh} shell. These latter ones will not be covered
  in this tutorial.
\item Recent versions of the \indextermbus{Apple}{Mac OS}
  have the \indexunix{zsh} as default.
  While this shell has many things in common with \n{bash},
  we will point out differences explicitly.
\end{itemize}

\Level 0 {Files and such}

\begin{purpose}
In this section you will learn about the Unix file system, which
consists of \indexterm{directories} that store \indexterm{files}. You
will learn about \indexterm{executable} files and commands for
displaying data files.
\end{purpose}

\Level 1 {Looking at files}

\begin{purpose}
In this section you will learn commands for displaying file contents.
\end{purpose}

\begin{stufflearned}
  \texttt{ls} & list files or directories\\
  \texttt{touch} & create new/empty file or update existing file\\
  \verb+cat > filename+ & enter text into file\\
  \texttt{cp} & copy files\\
  \texttt{mv} & rename files\\
  \texttt{rm} & remove files\\
  \texttt{file} & report the type of file\\
  \texttt{cat filename} & display file\\
  \texttt{head,tail} & display part of a file\\
  \texttt{less,more} & incrementally display a file\\
\end{stufflearned}

\Level 2 {\texttt{ls}}

Without any argument, the \indexunix{ls} command gives you a
listing of files that are in your present location.

%\practical
\begin{exercise}
  Type \indexunix{ls}. Does anything show up?
\end{exercise}
\begin{outcome}
  If there are files in your directory, they will be \n{l}i\n{s}ted;
  if there are none, no output will be given. This is standard Unix
  behavior: no output does not mean that something went wrong, it
  only means that there is nothing to report.
\end{outcome}

%\practical
\begin{exercise}
  If the \indexunix{ls} command shows that there are files, do
  \n{ls name} on one of those.
  By using an option, for instance \n{ls -s name}
  you can get more information about \n{name}.
\end{exercise}

\begin{caution}
  If you mistype a name, or specify a name of a
  non-existing file, you'll get an error message.
\end{caution}

The \indexunix{ls} command can give you all sorts of information.
In addition to the above \n{ls -s} for the size, there is
\n{ls -l} for the `long' listing.
It shows (things we will get to later such as) ownership and permissions,
as well as the size and creation date.

\begin{remark}
  There are several dates associated with a file, corresponding to
  changes in content, changes in permissions, and access of any
  sort. The \indexunix{stat} command gives all of them.
\end{remark}

\Level 2 {\texttt{cat}}

The \indexunix{cat} command (short for `concatenate')
is often used to display files, but it can also be
used to create some simple content. 

%\practical
\begin{exercise}
  Type \n{cat > newfilename} (where you can pick any filename) and
  type some text. Conclude with \n{Control-d} on a line by
  itself: press the \texttt{Control} key and hold it while you
  press the \texttt{d} key.  Now use \indexunix{cat} to view the
  contents of that file: \n{cat newfilename}.
\end{exercise}
\begin{outcome}
  In the first use of \indexunix{cat}, text was appended
  from the terminal to a file; in the second the file was cat'ed to
  the terminal output. You should see on your screen precisely what
  you typed into the file.
\end{outcome}
\begin{caution}
  Be sure to type \n{Control-d} as the first thing on the last line of input. If you
    really get stuck, \n{Control-c} will usually get you out. Try this:
    start creating a file with \n{cat > filename} and hit \n{Control-c} in
    the middle of a line. What are the contents of your file?
\end{caution}

\begin{remark}
  Instead of \n{Control-d} you will often see the notation~\n{^D}. 
  The capital letter is for historic reasons: you use the control key
  and the lowercase letter.
\end{remark}

\Level 2 {\texttt{man}}

The primary (though not always the most easily understood) source for unix commands
is the \indexunixdef{man} command, for `manual'.
The descriptions available this way are referred to as the \indexterm{manual page}s.

\begin{exercise}
  Read the man page of the \n{ls} command:
  \n{man ls}.
  Find out the size and the time~/ date of the last change
  to some files, for instance the file you just created.
\end{exercise}
\begin{outcome}
  Did you find the \n{ls -s} and \n{ls -l} options? The first one
  lists the size of each file, usually in kilobytes, the other gives
  all sorts of information about a file, including things you will
  learn about later.
\end{outcome}

The \indexunix{man} command
    puts you in a mode where you can view long text documents. This
    viewer is common on Unix systems (it is available as the \indexunix{more} or
    \indexunix{less} system command), so memorize the following ways of navigating: Use
    the space bar to go forward and the \n{u} key to go back up. Use
    \n{g} to go to the beginning fo the text, and \n{G} for the end. Use
    \n{q} to exit the viewer. If you really get stuck, \n{Control-c} will
    get you out.

\begin{remark}
  If you already know what command you're looking for, you can use man
  to get online information about it. If you forget the name of a
  command, \indexunix{man}~\n{-k keyword} can help you find it.
\end{remark}

\Level 2 {\texttt{touch}}

The \indexunix{touch} command creates an empty file, or updates the timestamp of
a file if it already exists. Use \n{ls -l} to confirm this behavior.

\Level 2 {\texttt{cp, mv, rm}}

The \indexunix{cp} can be used for copying a file (or directories,
see below): \n{cp file1 file2} makes a copy of \n{file1} and names it
\n{file2}.

%\practical
\begin{exercise}
  Use \n{cp file1 file2} to copy a file. Confirm that the two files
  have the same contents. If you change the original, does anything
  happen to the copy?
\end{exercise}
\begin{outcome}
  You should see that the copy does not change if the original changes
  or is deleted.
\end{outcome}
\begin{caution}
  If \n{file2} already exists, you
  will get an error message.
\end{caution}

A file can be renamed with \indexunix{mv}, for `move'.

%\practical
\begin{exercise}
  Rename a file. What happens if the target name already exists?
\end{exercise}


Files are deleted with \n{rm}. This command is dangerous: there is no
undo.
For this reason you can do \n{rm -i} (for `interactive') which
asks your confirmation for every file.

See section~\ref{sec:shell-wildcard} for more aggressive removing.

\Level 2 {\texttt{head, tail}}

There are more commands for displaying a file, parts of a file, or
information about a file. 

%\practical
\begin{exercise}
  Do \n{ls /usr/share/words} or \n{ls /usr/share/dict/words} to
  confirm that a file with words exists on your system. Now experiment
  with the commands \n{head}, \n{tail}, \n{more}, and \n{wc} using
  that file.
\end{exercise}
\begin{outcome}
  \indexunix{head} displays the first couple of lines of a file,
  \indexunix{tail} the last, and \indexunix{more} uses the
  same viewer that is used for man pages. Read the man pages for these
  commands and experiment with increasing and decreasing the amount of
  output.  The \indexunix{wc} (`word count') command reports the
  number of words, characters, and lines in a file.
\end{outcome}

Another useful command is \indexunix{file}: it tells you what
type of file you are dealing with.

%\practical
\begin{exercise}
  Do \n{file foo} for various `foo': a text file, a directory, or the
  \n{/bin/ls} command.
\end{exercise}
\begin{outcome}
  Some of the information may not be intelligible to you, but the
  words to look out for are `text', `directory', or `executable'.
\end{outcome}

At this point it is advisable to learn to use a text
\indexterm{editor}, such as \indexterm{emacs} or~\indexterm{vi}.

\Level 1 {Directories}

\begin{purpose}
  Here you will learn about the Unix directory tree, how to manipulate
  it and how to move around in it.
\end{purpose}

\begin{stufflearned}
  \texttt{ls} & list the contents of directories\\
  \texttt{mkdir} & make new directory\\
  \texttt{cd} & change directory\\
  \texttt{pwd} & display present working directory\\
\end{stufflearned}

A unix file system is a tree of directories, where a directory is a
container for files or more directories. We will display directories
as follows:

%% try forest :
%% https://tex.stackexchange.com/questions/5073/making-a-simple-directory-tree
\begin{comment}
  \begin{tabular}{rlr}
    \toprule
    /& &The root of the directory tree\\
    \texttt{|}&---\texttt{bin}&Binary programs\\
    \texttt{|}&---\texttt{home}&Location of user directories\\
    \bottomrule
  \end{tabular}
\end{comment}

\dirdisplay{.1 /\DTcomment{The root of the directory tree}. 
.2 bin\DTcomment{Binary programs}. .2 home\DTcomment{Location of
    users directories}. }

The root of the Unix directory tree is indicated with a slash. Do
\n{ls /} to see what the files and directories there are in the
root. Note that the root is not the location where you start when you
reboot your personal machine, or when you log in to a server.

%\practical
\begin{exercise}
  The command to find out your current working directory is
  \indexunix{pwd}. Your home directory is your working directory
  immediately when you log in. Find out your home directory.
\end{exercise}
\begin{outcome}
  You will typically see something like \n{/home/yourname} or
  \n{/Users/yourname}. This is system dependent.
\end{outcome}

Do \n{ls} to see the contents of the working directory. In the
displays in this section, directory names will be followed by a
slash:~\n{dir/} but this character is not part of their name.  You can
get this output by using \n{ls -F}, and you can tell your shell to
use this output consistently by stating \n{alias ls=ls -F} at the start of your
session. Example:

\dirdisplay{.1 /home/you/. .2 adirectory/. .2 afile. }

The command for making a new directory is \indexunix{mkdir}.

%\practical
\begin{exercise}
  Make a new directory with \indexunix{mkdir}~\n{newdir} and view
  the current directory with \n{ls}.
\end{exercise}
\begin{outcome}
  You should see this structure:
    \dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{the new directory}. }
\end{outcome}

The command for going into another directory, that is, making it your
working directory, is \indexunix{cd} (`change directory'). It can be used in
the following ways:
\begin{itemize}
\item \n{cd} Without any arguments, \n{cd} takes you to your home directory.
\item \n{cd <absolute path>} An absolute path starts at the root of
  the directory tree, that is, starts with~\n{/}. The \n{cd} command
  takes you to that location.
\item \n{cd <relative path>} A relative path is one that does not
  start at the root. This form of the \n{cd} command takes you to
  \n{<yourcurrentdir>/<relative path>}.
\end{itemize}

%\practical
\begin{exercise}
  Do \n{cd newdir} and find out where you are in the directory tree
  with \n{pwd}.  Confirm with \n{ls} that the directory is empty.  How
  would you get to this location using an absolute path?
\end{exercise}
\begin{outcome}
  \n{pwd} should tell you \n{/home/you/newdir}, and \n{ls} then has no
  output, meaning there is nothing to list.  The absolute path is
  \n{/home/you/newdir}.
\end{outcome}

%\practical
\begin{exercise}
  Let's quickly create a file in this directory: \indexunix{touch}
  \n{onefile}, and another directory: \n{mkdir otherdir}.  Do \n{ls}
  and confirm that there are a new file and directory.
\end{exercise}
\begin{outcome}
  You should now have: \dirdisplay{.1 /home/you/. .2
    newdir/\DTcomment{you are here}.  .3 onefile. .3 otherdir/. }
\end{outcome}

The \n{ls} command has a very useful option: with \n{ls -a} you see
your regular files and hidden files, which have a name that starts
with a dot. Doing \n{ls -a} in your new directory should tell you that
there are the following files:

\dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{you are here}. 
.3 .. .3 ... .3 onefile. .3 otherdir/. }

The single dot is the
current directory, and the double dot is the directory one level
back. 

%\practical
\begin{exercise}
  Predict where you will be after \n{cd ./otherdir/..}  and check to
  see if you were right.
\end{exercise}
\begin{outcome}
  The single dot sends you to the current directory, so that does not
  change anything. The \n{otherdir} part makes that subdirectory your
  current working directory. Finally, \n{..} goes one level back. In
  other words, this command puts your right back where you started.
\end{outcome}

Since your home directory is a special place, there are shortcuts for
\n{cd}'ing to it: \n{cd} without arguments, \n{cd ~}, and \n{cd \$HOME}
  all get you back to your home.

Go to your home directory, and from there do \n{ls newdir} to check
the contents of the first directory you created, without having to go
there.

%\practical
\begin{exercise}
  What does \n{ls ..} do?
\end{exercise}
\begin{outcome}
  Recall that \n{..} denotes the directory one level up in the tree:
  you should see your own home directory, plus the directories of any
  other users.
\end{outcome}

%\practical
\begin{exercise}
  Can you use \n{ls} to see the contents of someone else's home
  directory? In the previous exercise you saw whether other users
  exist on your system. If so, do \n{ls ../thatotheruser}.
\end{exercise}
\begin{outcome}
  If this is your private computer, you can probably view the contents
  of the other user's directory. If this is a university computer or
  so, the other directory may very well be protected --~permissions
  are discussed in the next section~-- and
  you get \n{ls: ../otheruser: Permission denied}.
\end{outcome}

Make an attempt to move into someone else's home directory with
\n{cd}. Does it work?

You can make copies of a directory with \n{cp}, but you need to add a
flag to indicate that you recursively copy the contents: \n{cp
  -r}. Make another directory \n{somedir} in your home so that you have

\dirdisplay{.1 /home/you/. .2 newdir/\DTcomment{you have been working
    in this one}. 
.2 somedir/\DTcomment{you just created this one}. }

What is the difference between
\n{cp -r newdir somedir}
and
\n{cp -r newdir thirddir}
where \n{thirddir} is not an
existing directory name?

\Level 1 {Permissions}
\label{sec:unix-permissions}

\begin{purpose}
  In this section you will learn about how to give various users on
  your system permission to do (or not to do) various things with your
  files.
\end{purpose}

Unix files, including directories,
have permissions, indicating `who can do what with this
file'. Actions that can be performed on a file fall into three
categories:
\begin{itemize}
\item reading \n{r}: any access to a file (displaying, getting information
  on it) that does not change the file;
\item writing \n{w}: access to a file that changes its content, or even its
  metadata such as `date modified';
\item executing \n{x}: if the file is executable, to run it; if it is a
  directory, to enter it.
\end{itemize}
The people who can potentially access a file are divided into three
classes too:
\begin{itemize}
\item the user \n{u}: the person owning the file;
\item the group \n{g}: a group of users to which the owner belongs;
\item other \n{o}: everyone else.
\end{itemize}
These nine permissions are rendered in sequence

\begin{fntable}{ccc}
  user&group&other\\ \midrule rwx&rwx&rwx \\
\end{fntable}

For instance
\n{rw-r--r--} means that the owner can read and write a file, the owner's
group and everyone else can only read. 

Permissions are also rendered
numerically in groups of three bits, by letting
$\mathtt{r}=4$, $\mathtt{w}=2$, $\mathtt{x}=1$:

\begin{fntable}{c}
 rwx\\ \midrule 421 \\ 
\end{fntable}

Common codes are $7=\mathtt{rwx}$ and $6=\mathtt{rw}$. You will find
many files that have permissions $755$ which stands for an executable
that everyone can run, but only the owner can change, or $644$ which
stands for a data file that everyone can see but again only the owner
can alter. You can set permissions by the \indexunix{chmod} command:
\begin{lstlisting}
  chmod <permissions> file         # just one file
  chmod -R <permissions> directory # directory, recursively
\end{lstlisting}
Examples:
\begin{lstlisting}
  chmod 766 file  # set to rwxrw-rw-
  chmod g+w file  # give group write permission
  chmod g=rx file # set group permissions
  chod o-w  file  # take away write permission from others
  chmod o=  file  # take away all permissions from others.
  chmod g+r,o-x file # give group read permission
                     # remove other execute permission
\end{lstlisting}
The man page gives all options.

%\practical
\begin{exercise}
  Make a file \n{foo} and do \n{chmod u-r foo}. Can you now inspect
  its contents? Make the file readable again, this time using a
  numeric code. Now make the file readable to your classmates. Check
  by having one of them read the contents.
\end{exercise}
\begin{outcome}
  1.~A~file is only accessible by others if the surrounding folder is
  readable. Can you figure out how to do this? 2.~When you've made the
  file `unreadable' by yourself, you can still \n{ls} it, but not
  \n{cat} it: that will give a `permission denied' message.
\end{outcome}

Make a file \n{com} with the following contents:
\begin{lstlisting}
#!/bin/sh
echo "Hello world!"
\end{lstlisting}
This is a legitimate shell script. What happens when you type
\n{./com}? Can you get the script executed?

In the three permission categories it is clear who `you' and `others'
refer to. How about `group'? We'll go into that in section~\ref{sec:users}.

\begin{exercise}
  Suppose you're an instructor and you want to make a `dropbox'
  directory for students to deposit homework assignments in.
  What would be an appropriate mode for that directory?
  (Assume that you have co-teachers that are in your group,
  and who also need to be able to see the contents. In other words,
  group permission should be identical to the owner permission.)
\end{exercise}


\begin{remark}
  There are more obscure permissions. For instance the
  \indexunix{setuid} bit declares that the program should run with the
  permissions of the creator, rather than the user executing it. This
  is useful for system utilities such \n{passwd} or \n{mkdir}, which
  alter the password file and the directory structure, for which
  \indextermbus{root}{privileges} are needed. Thanks to the setuid
  bit, a user can run these programs, which are then so designed that
  a user can only make changes to their own password entry, and their
  own directories, respectively. The setuid bit is set with
  \indexunix{chmod}: \n{chmod 4ugo file}.
\end{remark}

\Level 1 {Wildcards}
\label{sec:shell-wildcard}

You already saw that \n{ls filename} gives you information about that
one file, and \n{ls} gives you all files in the current directory. To
see files with certain conditions on their names, the
\indexterm{wildcard} mechanism exists. The following wildcards exist:

\begin{fntable}{ll}
  \verb+*+& any number of characters\\
  \verb+?+& any character.\\
\end{fntable}

Example:
\begin{lstlisting}
%% ls
s       sk      ski     skiing  skill
%% ls ski*
ski     skiing  skill
\end{lstlisting}
The second option lists all files whose name start with
\n{ski}, followed by any number of other characters'; below you will
see that in different contexts \n{ski*} means `\n{sk} followed by any
number of \n{i} characters'. Confusing, but that's the way it is.

You can use \n{rm} with wildcards, but this can be dangerous.
\begin{lstlisting}
rm -f foo    ## remove foo if it exists
rm -r foo    ## remove directory foo with everything in it
rm -rf foo/* ## delete all contents of foo
\end{lstlisting}

\begin{zshnote}{No match}
  Removing with a wildcard \n{rm foo*}
  is an error of there are no such files.
  Set \n{setopt +o nomatch} to allow no matches to occur.
\end{zshnote}

\Level 0 {Text searching and regular expressions}
\label{sec:regexp}

\begin{purpose}
  In this section you will learn how to search for text in files.
\end{purpose}

For this section you need at least one file that contains some amount
of text. You can for instance get random text from
\url{http://www.lipsum.com/feed/html}. 

The \indexunix{grep} command can be used to search for a text expression in a
file.

%\practical
\begin{exercise}
  Search for the letter \n{q} in your text file with \n{grep q
    yourfile} and search for it in all files in your directory with
  \n{grep q *}. Try some other searches.
\end{exercise}
\begin{outcome}
  In the first case, you get a listing of all lines that contain
  a~\n{q}; in the second case, \n{grep} also reports what file name
  the match was found in: \n{qfile:this line has q in it}.
\end{outcome}
\begin{caution}
  If the string you are looking for does not occur, \n{grep} will
    simply not output anything. Remember that this is standard behavior
    for Unix commands if there is nothing to report.
\end{caution}

In addition to searching for literal strings, you can look for more
general expressions.

\begin{fntable}{ll} 
  \verb+^+&the beginning of the line\\
  \verb+$+&the end of the line\\
  \verb+.+&any character\\
  \verb+*+&any number of repetitions \\
  \verb+[xyz]+&any of the characters \n{xyz}\\
\end{fntable}

This looks like the wildcard mechanism you just saw
(section~\ref{sec:shell-wildcard}) but it's subtly different. Compare
the example above with:
\begin{lstlisting}
%% cat s
sk
ski
skill
skiing
%% grep "ski*" s
sk
ski
skill
skiing
\end{lstlisting}
In the second case you search for a string consisting of \n{sk} and
any number of \n{i} characters, including zero of them.

Some more examples: you can find
\begin{itemize}
\item All lines that contain the letter `q' with \verb+grep q yourfile+;
\item All lines that start with an~`a' with \verb+grep "^a" yourfile+
  (if your search string contains special characters, it is a good
  idea to use quote marks to enclose it);
\item All lines that end with a digit with \verb+grep "[0-9]$" yourfile+.
\end{itemize}

%\practical
\begin{exercise}
  Construct the search strings for finding
    \begin{itemize}
    \item lines that start with an uppercase character, and
    \item lines that contain exactly one character.
    \end{itemize}
\end{exercise}
\begin{outcome}
  For the first, use the range characters \n{[]}, for the second use
  the period to match any character.
\end{outcome}

%\practical
\begin{exercise}
  Add a few lines \n{x = 1}, \n{x {} = 2}, \n{x {} {} = 3} (that is,
  have different numbers of spaces between \n{x} and the equals sign)
  to your test file, and make \n{grep} commands to search for all
  assignments to~\n{x}.
\end{exercise}

The characters in the table above have special meanings. If you want
to search that actual character, you have to \indexterm{escape} it.

%\practical
\begin{exercise}
  Make a test file that has both \n{abc} and \n{a.c} in it, on
  separate lines.
  Try the commands \n{grep "a.c" file}, \n{grep a\\.c file}, \n{grep "a\\.c" file.}
\end{exercise}
\begin{outcome}
  You will see that the period needs to be escaped, and the search
    string needs to be quoted. In the absence of either, you will see
    that \n{grep} also finds the \n{abc} string.
\end{outcome}

\Level 1 {Cutting up lines with \protect\texttt{cut}}

Another tool for editing lines is \indexunix{cut}, which will cut up a line
and display certain parts of it. For instance,
\begin{lstlisting}
cut -c 2-5 myfile
\end{lstlisting}
will display the characters in position 2--5 of every line of
\n{myfile}. Make a test file and verify this example.

Maybe more useful, you can give \n{cut} a delimiter character and have
it split a line on occurrences of that delimiter. For instance, your system
will mostly likely have a file \n{/etc/passwd} that contains user
information\footnote{This is traditionally the case; on Mac OS
  information about users is kept elsewhere and this file only
  contains system services.}, with every line consisting of fields
separated by colons. For instance:
\begin{lstlisting}
daemon:*:1:1:System Services:/var/root:/usr/bin/false
nobody:*:-2:-2:Unprivileged User:/var/empty:/usr/bin/false
root:*:0:0:System Administrator:/var/root:/bin/sh
\end{lstlisting}
The seventh and last field is the login shell of the user;
\n{/bin/false} indicates that the user is unable to log in.

You can display users and their login shells with:
\begin{lstlisting}
cut -d ":" -f 1,7 /etc/passwd
\end{lstlisting}
This tells \n{cut} to use the colon as delimiter, and to print fields
1~and~7.

\Level 0 {Other useful commands: \protect\texttt{tar}}

The \indexunix{tar} command stands for `tape archive',
that is, it was originally meant to package files on a tape.
(The `archive' part derives from the \indexunix{ar} command.)
These days, it's used to package files together for distribution
on web sites and such: if you want to publish a library of hundreds of files
this bundles them into a single file.

The two most common options are for 
\begin{enumerate}
\item creating a tar file:
\begin{lstlisting}
tar fc package.tar directory_with_stuff
\end{lstlisting}
pronounced `tar file create', and
\item unpacking a tar file:
\begin{lstlisting}
tar fx package.tar
# this creates the directory that was packaged
\end{lstlisting}
pronounced `tar file extract'.
\end{enumerate}
Text files can often be compressed to a large extent, so
adding the \n{z} compressiong for \indexunix{gzip}
is a good idea:
\begin{lstlisting}
tar fcz package.tar.gz directory_with_stuff
tar fx package.tar.gz
\end{lstlisting}
Naming the `gzipped' file \n{package.tgz}
is also common.

\Level 0 {Command execution}

If you type something in the shell,
you are actually asking the underlying interpreter to execute a command.
Some commands are built-ins, others can be names of programs that
are stored somewhere, in a system location or in your own account.
This section will go into the mechanisms.

\begin{remark}
  Like any good programming language, the shell language as comments.
  Any line starting with a hash character~\n{#} is ignored.
\end{remark}
\begin{zshnote}
  In Apple's zsh, the comment character is disabled. Do
\begin{lstlisting}
  setopt interactivecomments
\end{lstlisting}
to enable it.
\end{zshnote}

\Level 1 {Search paths}
\label{sec:PATH}

\begin{stufflearned}
  \lstinline+which+&location of executable command\\
  \lstinline+type+&description of commands, functions,~\ldots\\
\end{stufflearned}

\begin{purpose}
  In this section you will learn how Unix determines what to do when
  you type a command name.
\end{purpose}

If you type a command such as \n{ls}, the shell does not just rely on
a list of commands: it will actually go searching for a program by the
name \n{ls}. This means that you can have multiple different commands
with the same name, and which one gets executed depends on which one
is found first.

%\practical
\begin{exercise}
  What you may think of as `Unix commands' are often just executable
  files in a system directory. Do \indexunix{which}~\n{ls}, and do
  an \n{ls -l} on the result.
\end{exercise}
\begin{outcome}
  The location of \n{ls} is something like \n{/bin/ls}. If you
    \n{ls} that, you will see that it is probably owned by root. Its
    executable bits are probably set for all users.
\end{outcome}

The locations where unix searches for commands is the
\indextermdef{search path},
which is stored in the \indexterm{environment variable} (for more
details see below) \indexunixdef{PATH}.

%\practical
\begin{exercise}
  Do \n{echo \$PATH}. Can you find the location of \n{cd}?  Are there
  other commands in the same location? Is the current directory
  `\n{.}' in the path? If not, do \n{export PATH=".:\$PATH"}. Now
  create an executable file \n{cd} in the current director (see above
  for the basics), and do \n{cd}.
\end{exercise}
\begin{outcome}
  The path will be a list of colon-separated directories,\\ for
  instance \n{/usr/bin:/usr/local/bin:/usr/X11R6/bin}. If the working
  directory is in the path, it will probably be at the end:
  \n{/usr/X11R6/bin:.}  but most likely it will not be there. If you
  put `\n{.}' at the start of the path, unix will find the local
  \n{cd} command before the system one.
\end{outcome}

Some people consider having the working directory in the path a
security risk. If your directory is writable, someone could put a
malicious script named \n{cd} (or any other system command) in your
directory, and you would execute it unwittingly.

It is possible to define your own commands as aliases of existing
commands.

%\practical
\begin{exercise}
  Do \n{alias chdir=cd} and convince yourself that now \n{chdir} works
  just like \n{cd}. Do \n{alias rm='rm -i'}; look up the meaning of
  this in the man pages. Some people find this alias a good idea; can
  you see why?
\end{exercise}
\begin{outcome}
  The \n{-i} `interactive' option for \n{rm} makes the command ask for
  confirmation before each delete. Since unix does not have a trashcan
  that needs to be emptied explicitly (as on Windows or the Mac OS),
  this can be a good idea.
\end{outcome}

\begin{remark}
  Not all Unix commands correspond to executables. The
  \indexunixdef{type} command gives more information than \indexunix{which}:
\begin{lstlisting}
$ type echo
echo is a shell builtin
$ type \ls
ls is an alias for ls -F
$ unalias ls
$ type ls
ls is /bin/ls
$ type module
module is a shell function from /usr/local/Cellar/lmod/8.7.2/init/zsh
\end{lstlisting}
\end{remark}

\Level 1 {Command sequencing}
\label{tut:unix-bq}

There are various ways of having multiple commands on a single
commandline.

\Level 2 {Simple sequencing}

First of all, you can type
\begin{lstlisting}
command1 ; command2
\end{lstlisting}
This is convenient if you repeat the same two commands a number of
times: you only need to up-arrow once to repeat them both.

There is a problem: if you type
\begin{lstlisting}
cc -o myprog myprog.c ; ./myprog
\end{lstlisting}
and the compilation fails, the program will still be executed,
using an old version of the executable if that exists. This is very
confusing.

A better way is:
\begin{lstlisting}
cc -o myprog myprog.c && ./myprog
\end{lstlisting}
which only executes the second command if the first one was
successful.

\Level 2 {Pipelining}

Instead of taking input from a file, or sending output to a file, it
is possible to connect two commands together, so that the second takes
the output of the first as input. The syntax for this is
\verb+cmdone | cmdtwo+; this is called a pipeline. For instance,
\verb+grep a yourfile | grep b+ finds all lines that contains both an
\n{a} and a~\n{b}.

%\practical
\begin{exercise}
  Construct a pipeline that counts how many lines there are in your
  file that contain the string \n{th}. Use the \n{wc} command (see
  above) to do the counting.
\end{exercise}

\Level 2 {Backquoting}
\label{tut:unix-backquote}
\index{backtick|see{backquote}}

There are a few more ways to combine commands. Suppose you want to
present the result of \n{wc} a bit nicely. Type the following command
\begin{lstlisting}
echo The line count is wc -l foo
\end{lstlisting}
where \n{foo} is the name of an existing file. The way to
get the actual line count echoed is by the \indextermdef{backquote}:
\begin{lstlisting}
echo The line count is `wc -l foo`
\end{lstlisting}
Anything in between backquotes is executed before the rest of the
command line is evaluated.

\begin{exercise}
  The way \n{wc} is used here, it prints the
  file name. Can you find a way to prevent that from happening?
\end{exercise}

There is another mechanism for
out-of-order evaluation:
\begin{lstlisting}
echo "There are $( cat Makefile | wc -l ) lines"
\end{lstlisting}
This mechanism makes it possible to nest commands,
but for compatibility and legacy purposes backquotes
may still be preferable when nesting is not neeeded.

\Level 2 {Grouping in a subshell}

Suppose you want to apply output redirection to a couple of commands
in a row:
\begin{lstlisting}
  configure ; make ; make install > installation.log 2>&1
\end{lstlisting}
This only catches the last command. You could for instance group the
three commands in a subshell and catch the output of that:
\begin{lstlisting}
  ( configure ; make ; make install ) > installation.log 2>&1
\end{lstlisting}

\Level 1 {Exit status}

Commands can fail. If you type a single command on the command line,
you see the error, and you act accordingly when you type the next
command. When that failing command happens in a script, you have to
tell the script how to act accordingly. For this, you use the
\indexterm{exit status} of the command: this is a value (zero for
success, nonzero otherwise) that is stored in an internal variable,
and that you can access with \verb+$?+.

Example. Suppose we have a directory that is not writable
\begin{lstlisting}
[testing] ls -ld nowrite/
dr-xr-xr-x  2 eijkhout  506  68 May 19 12:32 nowrite//
[testing] cd nowrite/
\end{lstlisting}
and write try to create a file there:
\begin{lstlisting}
[nowrite] cat ../newfile 
#!/bin/bash
touch $1
echo "Created file: $1"
[nowrite] newfile myfile
bash: newfile: command not found
[nowrite] ../newfile myfile
touch: myfile: Permission denied
Created file: myfile
[nowrite] ls
[nowrite]
\end{lstlisting}
The script reports that the file was created even though it wasn't.

Improved script:
\begin{lstlisting}
[nowrite] cat ../betterfile
#!/bin/bash
touch $1
if [ $? -eq 0 ] ; then
    echo "Created file: $1"
else
    echo "Problem creating file: $1"
fi

[nowrite] ../betterfile myfile
touch: myfile: Permission denied
Problem creating file: myfile
\end{lstlisting}


\Level 1 {Processes and jobs}

\begin{stufflearned}
  \n{ps}&list (all) processes\\
  \n{kill}&kill a process\\
  \verb+CTRL-c+&kill the foreground job\\
  \verb+CTRL-z+&suspect the foreground job\\
  \n{jobs}&give the status of all jobs\\
  \n{fg}&bring the last suspended job to the foreground\\
  \verb+fg %3+&bring a specific job to the foreground\\
  \n{bg}&run the last suspended job in the background\\
\end{stufflearned}

The Unix operating system can run many programs at the same time, by
rotating through
the list and giving each only a  fraction of a second to run each time.
The command \indexunix{ps} can tell you everything that is currently running.

%\practical
\begin{exercise}
  Type \n{ps}. How many programs are currently running? By default
  \n{ps} gives you only programs that you explicitly started. Do \n{ps
    guwax} for a detailed list of everything that is running. How many
  programs are running? How many belong to the root user, how many to
  you?
\end{exercise}
\begin{outcome}
  To count the programs belonging to a user, pipe the \n{ps} command
  through an appropriate \n{grep}, which can then be piped to \n{wc}.
\end{outcome}

In this long listing of \n{ps}, the second column contains the
\emph{process numbers}\index{process!numbers}.
Sometimes it is useful to have those: if a program misbehaves you can
\indexunix{kill} it with
\begin{lstlisting}
kill 123456
\end{lstlisting}
where \n{12345} is the process number.

The \n{cut} command
explained above can
cut certain position from a line: type \n{ps guwax | cut -c 10-14}.

To get dynamic information about all running processes, use the
\n{top} command. Read the man page to find out how to sort the output
by CPU usage.

Processes that are started in a shell are known as
\emph{jobs}\indexterm{job (unix)}.
In addition to the process number, they have a job number.
We will now explore manipulating jobs.

When you type a command and hit return, that command becomes, for
the duration of its run, the \indexterm{foreground process}.
Everything else that is running at the same time is a
\indexterm{background process}.

Make an executable file \n{hello} with the following contents:
\begin{lstlisting}
#!/bin/sh
while [ 1 ] ; do
  sleep 2
  date
done
\end{lstlisting}
and type \n{./hello}. 

%\practical
\begin{exercise}
  Type \n{Control-z}. This suspends the foreground process. It will
  give you a number like \n{[1]} or \n{[2]} indicating that it is the
  first or second program that has been suspended or put in the
  background. Now type \n{bg} to put this process in the
  background. Confirm that there is no foreground process by hitting
  return, and doing an \n{ls}.
\end{exercise}
\begin{outcome}
  After you put a process in the background, the terminal is available
  again to accept foreground commands. If you hit return, you should
  see the command prompt. However, the background process still keeps
  generating output.
\end{outcome}

%\practical
\begin{exercise}
  Type \n{jobs} to see the processes in the current session. If the
  process you just put in the background was number~1,
  type \n{fg  \%1}. Confirm that it is a foreground process again.
\end{exercise}
\begin{outcome}
  If a shell is executing a program in the foreground, it will not
  accept command input, so hitting return should only produce blank
  lines.
\end{outcome}

%\practical
\begin{exercise}
  When you have made the \n{hello} script a foreground
    process again, you can kill it with \n{Control-c}. Try this. Start
    the script up again, this time as \n{./hello \&} which immediately
    puts it in the background. You should also get output along the
    lines of \n{[1] 12345} which tells you that it is the first job you
    put in the background, and that \n{12345} is its process ID. Kill
    the script with \n{kill \%1}. Start it up again, and kill it by
    using the process number.
\end{exercise}
\begin{outcome}
  The command \n{kill 12345} using the process number is usually
  enough to kill a running program. Sometimes it is necessary to use
  \n{kill -9 12345}.
\end{outcome}

\Level 1 {Shell customization}

Above it was mentioned that \n{ls -F} is an easy way to see which
files are regular, executable, or directories; by typing \n{alias
  ls='ls -F'} the \n{ls} command will automatically expanded to \n{ls
  -F} every time it is invoked. If you would like this behavior in
every login session, you can add the \n{alias} command to your
\n{.profile} file. Other shells than \n{sh}/\n{bash} have other files for such
customizations.

\Level 0 {Input/output Redirection}
\label{sec:unixpipe}
\index{input redirection|see{redirection}}
\index{output redirection|see{redirection}}

\begin{purpose}
  In this section you will learn how to feed one command into another,
  and how to connect commands to input and output files.
\end{purpose}

So far, the unix commands you have used have taken their input from
your keyboard, or from a file named on the command line; their output
went to your screen. There are other possibilities for providing input
from a file, or for storing the output in a file.

\Level 1 {Input redirection}
\index{redirection|(textbf}

The \n{grep} command had two arguments, the second being a file
name. You can also write \n{grep string < yourfile}, where the
less-than sign means that the input will come from the named file,
\n{yourfile}. This is known as \emph{input redirection}.

\Level 1 {Standard files}

Unix has three standard files that handle input and output:

\begin{stufflearned}[Standard file]
  \texttt{stdin}& is the file that provides input for processes.\\
  \texttt{stdout}& is the file where the output of a process is  written.\\
  \texttt{stderr}& is the file where error output is written.\\
\end{stufflearned}

In an interactive session, all three files are connected to the user
terminal. Using input or output redirection then means that the input
is taken or the output sent to a different file than the terminal.

\Level 1 {Output redirection}

Just as with the input, you can redirect the output of your program.
In the simplest case,
\n{grep string yourfile > outfile}
will take what
normally goes to the terminal, and \emph{redirect}
the output to \n{outfile}. The output
file is created if it didn't already exist, otherwise it is
overwritten. (To append, use \n{grep text yourfile >> outfile}.)

%\practical
\begin{exercise}
  Take one of the grep commands from the previous section, and send
  its output to a file. Check that the contents of the file are
  identical to what appeared on your screen before. Search for a
  string that does not appear in the file and send the output to a
  file. What does this mean for the output file?
\end{exercise}
\begin{outcome}
  Searching for a string that does not occur in a file gives no
  terminal output. If you redirect the output of this \n{grep} to a
  file, it gives a zero size file. Check this with \n{ls} and \n{wc}.
\end{outcome}

Sometimes you want to run a program, but ignore the output.
For that, you can redirect your output to the system
\indextermsub{null}{device}: \indextermtt{/dev/null}.
\begin{lstlisting}
yourprogram >/dev/null
\end{lstlisting}
Here are some useful idioms:

\begin{stufflearned}[Idiom]
  \n{program 2>/dev/null}&send only errors to the null device\\
  \n{program >/dev/null 2>&1}&send output to dev-null, and errors to output\\
  &Note the counterintuitive sequence of specifications!\\
  \n{program 2>&1 | less}& send output and errors to \n{less}\\
\end{stufflearned}

\index{redirection|)}

\Level 0 {Shell environment variables}
\label{tut:shellvars}
\index{environment variable|(textbf}

Above you encountered \n{PATH}, which is an example of an
shell, or environment, variable. These are variables that are known to the shell
and that can be used by all programs run by the shell.
While \n{PATH} is a built-in variable, you can also define your own
variables, and use those in shell scripting.

Shell variables are roughly divided in the following categories:
\begin{itemize}
\item Variables that are specific to the shell, such as \n{HOME} or \n{PATH}.
\item Variables that are specific to some program, such as \n{TEXINPUTS} for \TeX/\LaTeX.
\item Variables that you define yourself; see next.
\item Variables that are defined by control structures such as \indexunix{for};
  see below.
\end{itemize}

You can see the
full list of all variables known to the shell by typing \indexunixdef{env}.
\begin{remark}
  This does not include variables you define yourself, unless you \indexunix{export} them;
  see below.
\end{remark}

%\practical
\begin{exercise}
  Check on the value of the \n{PATH} variable by typing
    \n{echo \$PATH}. Also find the value of \n{PATH} by piping \n{env}
    through \n{grep}.
\end{exercise}

We start by exploring the use of this dollar sign in relation to shell variables.

\Level 1 {Use of shell variables}

You can get the value of a shell variable by prefixing it with
a dollar sign.
Type the following and inspect the output:
\begin{lstlisting}
echo x
echo $x
x=5
echo x
echo $x
\end{lstlisting}

You see that the shell treats everything as a string, unless you explicitly tell it
to take the value of a variable, by putting a dollar in front of the name.
A~variable that has not been previously defined will print as a blank string.

Shell variables can be set in a number of ways. The simplest
is by an assignment as in other programming languages.

When you do the next exercise,
it is good to bear in mind that the shell is a text based language.

%\practical
\begin{exercise}
  Type \n{a=5} on the commandline. Check on its value with the \n{echo} command.

  Define the variable \n{b} to another integer. Check on its value.

  Now explore the values of \n{a+b} and \n{$a+$b}, both by \n{echo}'ing them,
  or by first assigning them.
\end{exercise}
\begin{outcome}
  The shell does not perform integer addition here: instead you get a string
  with a plus-sign in it.
  (You will see how to do arithmetic on variables in section~\ref{sec:arith-expansion}.)
\end{outcome}
\begin{caution}
  Beware not to have space
    around the equals sign; also be sure to use the dollar sign to print
    the value.
\end{caution}

\Level 1 {Exporting variables}

A variable set this way will be known to all subsequent commands
you issue in this shell, but not to commands in new shells you start up.
For that you need the \indexunix{export} command.
Reproduce the following session (the square brackets form the command prompt):
\begin{lstlisting}
[] a=20
[] echo $a
20
[] /bin/bash
[] echo $a

[] exit
exit
[] export a=21
[] /bin/bash
[] echo $a
21
[] exit
\end{lstlisting}

You can also temporarily set a variable. Replay this scenario:
\begin{enumerate}
\item Find an environment variable that does not have a value:
\begin{lstlisting}
[] echo $b

[]
\end{lstlisting}
\item Write a short shell script to print this variable:
\begin{lstlisting}
[] cat > echob
#!/bin/bash
echo $b
\end{lstlisting}
and of course make it executable: \n{chmod +x echob}.
\item Now call the script, preceding it with a setting of the variable~\n{b}:
\begin{lstlisting}
[] b=5 ./echob
5
\end{lstlisting}
The syntax where you set the value, as a prefix without using a separate
command, sets the value just for that one command.
\item Show that the variable is still undefined:
\begin{lstlisting}
[] echo $b

[]
\end{lstlisting}
That is, you defined the variable just for the execution of a single command.
\end{enumerate}

In  section~\ref{sec:shell-control} you will see that the \n{for} construct
also defines a variable; section~\ref{sec:shell-scripting}
shows some more built-in variables that apply in shell scripts.

If you want to un-set an environment variable,
there is the \indexunix{unset} command.

\index{environment variable|)}

\Level 0 {Control structures}
\label{sec:shell-control}

Like any good programming system, the shell has some control
structures. Their syntax takes a bit of getting used to. (Different
shells have different syntax; in this tutorial we only discuss the
bash shell.

\Level 1 {Conditionals}

The \emph{conditional} of the bash shell is predictably called
\indexunixdef{if}, and it can be written over several
lines:
\begin{lstlisting}
if [ $PATH = "" ] ; then
  echo "Error: path is empty"
fi
\end{lstlisting}
or on a single line:
\begin{lstlisting}
if [ `wc -l file` -gt 100 ] ; then echo "file too long" ; fi
\end{lstlisting}
(The backquote is explained in section~\ref{tut:unix-backquote}.)
There are a number of tests defined, for instance \n{-f somefile}
tests for the existence of a file. Change your script so that it will
report \n{-1} if the file does not exist.

The syntax of this is finicky:
\begin{itemize}
\item \indexunix{if} and \indexunix{elif} are followed by a
  conditional, followed by a semicolon.
\item The brackets of the conditional need to have spaces surrounding
  them.
\item There is no semicolon after \indexunix{then} of \indexunix{else}:
  they are immediately followed by some command.
\end{itemize}

\begin{exercise}
  Bash conditionals have an \indexunix{elif} keyword.
  Can you predict the error you get from this:
\begin{lstlisting}
if [ something ] ; then
  foo
else if [ something_else ] ; then
  bar
fi
\end{lstlisting}
Code it out and see if you were right.
\end{exercise}

\begin{zshnote}
  The \indexunix{zsh} shell has an extended conditional syntax
  with double square brackets.
  For instance, pattern matching:
  \begin{lstlisting}
    if [[ $myvar == *substring* ]] ; then ....
  \end{lstlisting}
\end{zshnote}

\Level 1 {Looping}
\label{sec:unix-loop}

In addition to conditionals,
the shell has loops. A~\indexunix{for} loop looks like
\begin{lstlisting}
for var in listofitems ; do
  something with $var
done
\end{lstlisting}
This does the following:
\begin{itemize}
\item for each item in \n{listofitems}, the variable \n{var} is set to the
  item, and
\item the loop body is executed.
\end{itemize}
As a simple example:
\begin{lstlisting}
for x in a b c ; do echo $x ; done
a
b
c
\end{lstlisting}
In a more meaningful example,
here is how you would make backups of all your~\n{.c}
files:
\begin{lstlisting}
for cfile in *.c ; do
  cp $cfile $cfile.bak
done
\end{lstlisting}
Shell variables can be manipulated in a number of ways.
Execute the following commands to see that you can remove trailing
characters from a variable:
\begin{lstlisting}
[] a=b.c
[] echo ${a%.c}
b
\end{lstlisting}
(See the section~\ref{tut:unix-expansion} on expansion.)
With this as a hint, write a loop that renames all your \n{.c} files
to~\n{.x} files.

The above construct loops over words, such as the output of
\n{ls}. To do a numeric loop, use the command \indexunixdef{seq}:
\begin{lstlisting}
[shell:474] seq 1 5
1
2
3
4
5
\end{lstlisting}
Looping over a sequence of numbers then typically looks like
\begin{lstlisting}
for i in `seq 1 ${HOWMANY}` ; do echo $i ; done
\end{lstlisting}
Note the \indexterm{backtick}, which is necessary to have the \n{seq}
command executed before evaluating the loop.

\Level 0 {Scripting}
\label{sec:unix-script}

The unix shells are also programming environments. You will learn more
about this aspect of unix in this section.

\Level 1 {How to execute scripts}
\label{sec:shell-scripting}

It is possible to write programs of unix shell commands. First you
need to know how to put a program in a file and have it be
executed. Make a file \n{script1} containing the following two lines:
\begin{lstlisting}
#!/bin/bash
echo "hello world"
\end{lstlisting}
and type \n{./script1} on the command line. Result?
Make the file executable and try again.

\begin{zshnote}{Bash scripts}
  If you use the \n{zsh}, but you have \n{bash} scripts
  that you wrote in the past, they will keep working.
  The `hash-bang' line determines which shell executes the script,
  and it is perfectly possible to have \n{bash} in your script,
  while using \n{zsh} for interactive use.
\end{zshnote}

In order write scripts that you want to invoke from anywhere, people
typically put them in a directory \n{bin} in their home directory.
You would then add this directory to your \indexterm{search path},
contained in \indexunix{PATH}; see section~\ref{sec:PATH}.

\Level 1 {Script arguments}

You can invoke a shell script with options and arguments:
\begin{lstlisting}
./my_script -a file1 -t -x file2 file3
\end{lstlisting}

You will now learn how to incorporate this functionality in your scripts.

First of all, all commandline arguments and options are available
as variables \verb+$1+,\verb+$2+ et cetera in the script, and
the number of command line arguments is available as \verb+$#+:
\begin{lstlisting}
#!/bin/bash

echo "The first argument is $1"
echo "There were $# arguments in all"
\end{lstlisting}

Formally:\\
\begin{fntable}{ll}
  variable&meaning\\
  \midrule
  \verb+$#+&number of arguments\\
  \verb+$0+&the name of the script\\
  \verb+$1,$2,...+&the arguments\\
  \verb+$*,$@+&the list of all arguments\\
\end{fntable}

\begin{exercise}
  Write a script that takes as input a file name argument, and reports how many
  lines are in that file.

  Edit your script to test whether the file has less than 10 lines
  (use the \n{foo -lt bar} test), and if it does, \n{cat} the
  file. Hint: you need to use backquotes inside the test.

  Add a
  test to your script so that it will give a helpful message if you call
  it without any arguments.
\end{exercise}

The standard way to parse argument is using the \indexunixdef{shift}
command, which pops the first argument off the list of arguments.
Parsing the arguments in sequence then involves looking at \verb+$1+,
shifting, and looking at the new \verb+$1+.
%
\snippetwithoutput{argumentshift}{code/shell}{arguments}

\begin{exercise}
  Write a script \n{say.sh} that prints its text argument. However, if you invoke it with 
\begin{lstlisting}
./say.sh -n 7 "Hello world"
\end{lstlisting}
  it should be print it as many times as you indicated. Using the
  option \n{-u}:
\begin{lstlisting}
./say.sh -u -n 7 "Goodbye cruel world"
\end{lstlisting}
  should print the message in uppercase. Make sure that the order of
  the arguments does not matter, and give an error message for any
  unrecognized option.
\end{exercise}

The variables \verb+$@+ and \verb+$*+ have a different behavior with
respect to double quotes. Let's say we evaluate
\verb+myscript "1 2" 3+, then
\begin{itemize}
\item Using \verb+$*+ is the list of arguments after removing quotes:
  \verb+myscript 1 2 3+.
\item Using
  \verb+"$*"+ is the list of arguments, with quotes removed, in quotes:
  \verb+myscript "1 2 3"+.
\item Using
  \verb+"$@"+ preserved quotes:
  \verb+myscript "1 2" 3+.
\end{itemize}

\Level 0 {Expansion}
\label{tut:unix-expansion}

The shell performs various kinds of expansion on a command line, that
is, replacing part of the commandline with different text.

Brace expansion:
\begin{lstlisting}
[] echo a{b,cc,ddd}e
abe acce addde
\end{lstlisting}
This can for instance be used to delete all extension of some base
file name:
\begin{lstlisting}
[] rm tmp.{c,s,o}  # delete tmp.c tmp.s tmp.o
\end{lstlisting}

Tilde expansion gives your own, or someone else's home directory:
\begin{lstlisting}
[] echo ~
/share/home/00434/eijkhout
[] echo ~eijkhout
/share/home/00434/eijkhout
\end{lstlisting}

Parameter expansion gives the value of shell variables:
\begin{lstlisting}
[] x=5
[] echo $x
5
\end{lstlisting}
Undefined variables do not give an error message:
\begin{lstlisting}
[] echo $y
\end{lstlisting}
There are many variations on parameter expansion. Above you already
saw that you can strip trailing characters:
\begin{lstlisting}
[] a=b.c
[] echo ${a%.c}
b
\end{lstlisting}
Here is how you can deal with undefined variables:
\begin{lstlisting}
[] echo ${y:-0}
0
\end{lstlisting}

\begin{comment}
There are ways of doing pattern matching and substitution 
on a variable:
\begin{lstlisting}
[] f=x.fort
[] echo ${f%%.fort}
x
[] echo ${f%%.fort}.bak
x.bak
\end{lstlisting}
\end{comment}

The backquote mechanism (section~\ref{tut:unix-backquote} above)
is known as command substitution. It allows you to evaluate part
of a command and use it as input for another. For example,
if you want to ask what type of file the command \n{ls} is, do
\begin{lstlisting}
[] file `which ls`
\end{lstlisting}
This first evaluates \n{which ls}, giving \n{/bin/ls}, and then
evaluates \n{file /bin/ls}. As another example, here
we backquote a whole pipeline, and do a test on the result:
\begin{lstlisting}
[] echo 123 > w
[] cat w
123
[] wc -c w
       4 w
[] if [ `cat w | wc -c` -eq 4 ] ; then echo four ; fi
four
\end{lstlisting}

\Level 1 {Arithmetic expansion}
\label{sec:arith-expansion}

Unix shell programming is very much oriented towards text manipulation, but it 
is possible to do arithmetic. 
Arithmetic substitution tells the shell to treat the expansion of a
parameter as a number:
\begin{lstlisting}
[] x=1
[] echo $((x*2))
2
\end{lstlisting}

Integer ranges can be used as follows:
\begin{lstlisting}
[] for i in {1..10} ; do echo $i ; done
1
2
3
4
5
6
7
8
9
10
\end{lstlisting}
(but see also the \indexunix{seq} command in section~\ref{sec:unix-loop}.)

\Level 0 {Startup files}
\index{shell!startup files|(textbf}
\index{.profile@{\texttt{.profile}}|see{shell, startup files}}
\index{.bashrc@{\texttt{.bashrc}}|see{shell, startup files}}

In this tutorial you have seen several mechanisms for customizing
the behavior of your shell. For instance, by setting the \n{PATH}
variable you can extend the locations where the shell looks for executables.
Other environment variables (section~\ref{tut:shellvars}) you can
introduce for your own purposes. Many of these customizations will
need to apply to every session, so you can have 
\emph{shell startup files} that will be read at the start of any session.

Popular things to do in a startup file are defining \indexunix{alias}es:
\begin{lstlisting}
alias grep='grep -i'
alias ls='ls -F'
\end{lstlisting}
and setting a custom commandline \indexterm{prompt}.

The name of the startup file depends on your shell:
\indextermtt{.bashrc} for Bash,
\indextermtt{.cshrc} for the C-shell, and
\indextermtt{.zshrc} for the Z-shell.
These files are read everytime you log in (see below for details),
but you can also \indexunix{source} them directly:
\begin{lstlisting}
source ~/.bashrc
\end{lstlisting}
You would do this, for instance, if you have edited your startup file.

Unfortunately, there are several startup files, and which one gets read
is a complicated functions of circumstances. Here is a good common sense
guideline\footnote{Many thanks to Robert McLay for figuring this out.}:
\begin{itemize}
\item Have a \n{.profile} that does nothing but read the \n{.bashrc}:
\begin{lstlisting}
# ~/.profile
if [ -f ~/.bashrc ]; then
    source ~/.bashrc
fi
\end{lstlisting}
\item Your \n{.bashrc} does the actual customizations:
\begin{lstlisting}
# ~/.bashrc
# make sure your path is updated
if [ -z "$MYPATH" ]; then
  export MYPATH=1
  export PATH=$HOME/bin:$PATH
fi
\end{lstlisting}
\end{itemize}

\index{shell!startup files|)textbf}

\Level 0 {Shell interaction}

Interactive use of Unix, in contrast to script writing
(section~\ref{sec:unix-script}), is a complicated conversation between
the user and the shell. You, the user, type a line, hit return, and
the shell tries to interpret it. There are several cases.
\begin{itemize}
\item Your line contains one full command, such as \n{ls foo}: the
  shell will execute this command.
\item You can put more than one command on a line, separated by
  semicolons: \n{mkdir foo; cd foo}. The shell will execute these
  commands in sequence.
\item Your input line is not a full command, for instance \n{while [
    1]}. The shell will recognize that there is more to come, and use
  a different prompt to show you that it is waiting for the remainder
  of the command.
\item Your input line would be a legitimate command, but you want to
  type more on a second line. In that case you can end your input line
  with a backslash character, and the shell will recognize that it
  needs to hold off on executing your command. In effect, the
  backslash will hide (\indexterm{escape}) the return.
\end{itemize}

When the shell has collected a command line to execute, by using one or
more of your input line or only part of one, as described just now, it
will apply expansion to the command line
(section~\ref{tut:unix-expansion}). It will then interpret the
commandline as a command and arguments, and proceed to invoke that
command with the arguments as found.

There are some subtleties here. If you type \n{ls *.c}, then the shell
will recognize the wildcard character and expand it to a command line,
for instance \n{ls foo.c bar.c}. Then it will invoke the \n{ls}
command with the argument list \n{foo.c bar.c}. Note that \n{ls} does
not receive \n{*.c} as argument! In cases where you do want the unix
command to receive an argument with a wildcard, you need to escape it
so that the shell will not expand it. For instance, \n{find . -name
  \\*.c} will make the shell invoke \n{find} with arguments \n{. -name
  *.c}.

\Level 0 {The system and other users}
\label{sec:users}

Unix is a multi-user operating system. Thus, even if you use it
on your own personal machine, you are a user with an \emph{account}\index{Unix!user account}
and you may occasionally
have to type in your username and password.

If you are on your personal machine, you may be the only user logged
in. On university machines or other servers, there will often be other
users. Here are some commands relating to them.

\begin{itemize}
\item [\indexunix{whoami}] show your login name.
\item [\indexunix{who}] show the other users currently logged in.
\item [\indexunix{finger} {\tt otheruser}] get information about another user;
  you can specify a user's login name here, or their real name,
  or other identifying information the system knows about.
\item [\indexunix{top}] which processes are running on the system; use
  \n{top -u} to get this sorted the amount of cpu time they are
  currently taking. (On Linux, try also the \n{vmstat} command.)
\item [\indexunix{uptime}] how long has it been since your last reboot?
\end{itemize}

\Level 1 {Groups}

In section~\ref{sec:unix-permissions} you saw that there is a
permissions category for `group'. This allows you to open up files to
your close collaborators, while leaving them protected from the wide
world.

When your account is created, your system administrator will have
assigned you to one or more groups. (If you admin your own machine,
you'll be in some default group; read on for adding yourself to more groups.)

The command \indexunix{groups}
tells you all the groups you are in, and \n{ls -l} tells you
what group a file belongs to. Analogous to \n{chmod},
you can use \indexunix{chgrp} to change the group to
which a file belongs, to share it with a user who is also in that group.

Creating a new group, or
adding a user to a group needs system privileges.
To create a group:
\begin{lstlisting}
sudo groupadd new_group_name
\end{lstlisting}
To add a user to a group:
\begin{lstlisting}
sudo usermod -a -G thegroup theuser
\end{lstlisting}

\Level 1 {The super user}

Even if you own your machine, there are good reasons to work as much
as possible from a regular user account, and use
\indextermbus{root}{privileges} only when strictly needed.
%
(The root account is also known as the \indextermsubdef{super}{user}.)
%
If you have root privileges, you can also use that to `become another
user' and do things with their privileges, with the
\indexunixdef{sudo} (`superuser do') command.

\begin{itemize}
\item To execute a command as another user:
\begin{lstlisting}
sudo -u otheruser command arguments
\end{lstlisting}
\item To execute a command as the root user:
\begin{lstlisting}
sudo command arguments
\end{lstlisting}
\item Become another user:
\begin{lstlisting}
sudo su - otheruser
\end{lstlisting}
\item Become the \indextermsub{super}{user}:
\begin{lstlisting}
sudo su -
\end{lstlisting}
\end{itemize}

\Level 0 {Connecting to other machines: {\tt ssh} and {\tt scp}}

No man is an island, and no computer is either. Sometimes you want to
use one computer, for instance your laptop, to connect to another, for
instance a supercomputer.

If you are already on a Unix computer, you can log into another with
the `secure shell' command~\indexunixdef{ssh}, a~more secure variant
of the old `remote shell' command~\indexunixdef{rsh}:
\begin{lstlisting}
ssh yourname@othermachine.otheruniversity.edu
\end{lstlisting}
where the \n{yourname} can be omitted if you have the same name on
both machines.

To only copy a file from one machine to another you can use the
`secure copy' \indexunixdef{scp}, a~secure variant of `remote
copy'~\indexunixdef{rcp}. The \n{scp} command is much like \n{cp} in syntax,
except that the source or destination can have a machine prefix.

To copy a file from the current machine to
another, type:
\begin{lstlisting}
scp localfile yourname@othercomputer:otherdirectory
\end{lstlisting}
where \n{yourname} can again be omitted, and \n{otherdirectory} can be
an absolute path, or a path relative to your home directory:
\begin{lstlisting}
# absolute path:
scp localfile yourname@othercomputer:/share/
# path relative to your home directory:
scp localfile yourname@othercomputer:mysubdirectory
\end{lstlisting}
Leaving the destination path empty puts the file in the remote home directory:
\begin{lstlisting}
scp localfile yourname@othercomputer:
\end{lstlisting}
Note the colon at the end of this command: if you leave it out you get
a local file with an `at' in the name.

You can also copy a file from the remote machine. For instance, to
copy a file, preserving the name:
\begin{lstlisting}
scp yourname@othercomputer:otherdirectory/otherfile .
\end{lstlisting}

\Level 0 {The {\tt sed} and {\tt awk} tools}

Apart from fairly small utilities such as \n{tr} and \n{cut}, Unix
has some more powerful tools. In this section you will see two tools for
line-by-line transformations on text files. Of course this tutorial
merely touches on the depth of these tools; for more information
see~\cite{AWK:awk,OReilly:sedawk}.

\Level 1 {Stream editing with \protect\texttt{sed}}

Unix has various tools for processing text files on a line-by-line
basis.
The stream editor \indexunix{sed} is one example. If you have used the
\n{vi} editor, you are probably used to a syntax like
\verb+s/foo/bar/+ for making changes.
With \n{sed}, you can do this on the commandline.
For instance
\begin{lstlisting}
sed 's/foo/bar/' myfile > mynewfile
\end{lstlisting}
will apply the substitute command \n{s/foo/bar/} to every line of
\n{myfile}. The output is shown on your screen so you should capture
it in a new file; see section~\ref{sec:unixpipe} for more on output
\indexterm{redirection}.

\begin{itemize}
\item If you have more than one edit, you can specify them with
\begin{lstlisting}
sed -e 's/one/two/' -e 's/three/four/'
\end{lstlisting}
\item If an edit needs to be done only on certain lines, you can
  specify that by prefixing the edit with the match string. For instance
\begin{lstlisting}
sed '/^a/s/b/c/'
\end{lstlisting}
only applies the edit on lines that start with an~\n{a}. (See
section~\ref{sec:regexp} for regular expressions.)

You can also apply it on a numbered line:
\begin{lstlisting}
sed '25/s/foo/bar'
\end{lstlisting}
\item The \n{a} and \n{i} commands are for `append' and `insert' respectively.
  They are somewhat strange in how they take their argument text:
  the command letter is followed by a backslash, with the insert/append
  text on the next line(s), delimited by the closing quote of the command.
\begin{lstlisting}
sed -e '/here/a\
appended text
' -e '/there/i\
inserted text
' -i file
\end{lstlisting}
\item Traditionally, \n{sed} could only function in a stream, so
  the output file always had to be different from the input. The GNU
  version, which is standard on Linux systems, has a flag \n{-i} which
  edits `in place':
\begin{lstlisting}
sed -e 's/ab/cd/' -e 's/ef/gh/' -i thefile
\end{lstlisting}
\end{itemize}

\Level 1 {\tt awk}

The \indexunixdef{awk} utility also operates on each line, but it can be
described as having a memory. An awk program consists of a sequence of
pairs, where each pair consists of a match string and an action. The
simplest awk program is
\begin{lstlisting}
cat somefile | awk '{ print }'
\end{lstlisting}
where the match string is omitted, meaning that all lines match, and
the action is to print the line. Awk breaks each line into fields
separated by whitespace. A~common application of awk is to print a
certain field:
\begin{lstlisting}
awk '{print $2}' file
\end{lstlisting}
prints the second field of each line.

Suppose you want to print all subroutines in a Fortran program; this
can be accomplished with
\begin{lstlisting}
awk '/subroutine/ {print}' yourfile.f
\end{lstlisting}

\begin{exercise}
  Build a command pipeline that prints of each subroutine header only
  the subroutine name. For this you first use \n{sed} to replace the
  parentheses by spaces, then \n{awk} to print the subroutine name
  field.
\end{exercise}

Awk has variables with which it can remember things. For instance,
instead of just printing the second field of every line, you can make
a list of them and print that later:
\begin{lstlisting}
cat myfile | awk 'BEGIN {v="Fields:"} {v=v " " $2} END {print v}'
\end{lstlisting}

As another example of the use of variables, here is how you would
print all lines in between a \n{BEGIN} and \n{END} line:
\begin{lstlisting}
cat myfile | awk '/END/ {p=0} p==1 {print} /BEGIN/ {p=1} '
\end{lstlisting}

\begin{exercise}
  The placement of the match with \n{BEGIN} and \n{END} may seem
  strange. Rearrange the awk program, test it out, and explain the
  results you get.
\end{exercise}

\Level 0 {Review questions}

\begin{exercise}
    Devise a pipeline that counts how many users are logged onto
    the system, whose name starts with a vowel and ends with a
    consonant.
\end{exercise}

\begin{exercise}
  \label{tut:ex:plagiarism}
  Pretend that you're a professor writing a script for homework
  submission: if a student invokes this script it copies the student
  file to some standard location.
\begin{lstlisting}
submit_homework myfile.txt
\end{lstlisting}
  For simplicity, we simulate this by making a directory
  \n{submissions} and two different files \n{student1.txt} and
  \n{student2.txt}. After
\begin{lstlisting}
submit_homework student1.txt
submit_homework student2.txt
\end{lstlisting}
  there should be copies of both files in the \n{submissions}
  directory. Start by writing a simple script; it should give a
  helpful message if you use it the wrong way.

  Try to detect if a student is cheating. Explore the
  \indexunix{diff} command to see if the submitted file is
  identical to something already submitted:
  loop over all submitted files and
  \begin{enumerate}
  \item First print out all differences.
  \item Count the differences.
  \item Test if this count is zero.
  \end{enumerate}
  Now refine your test by catching if the cheating student randomly
  inserted some spaces.

  For a harder test: try to detect whether the cheating student
  inserted newlines. This can not be done with \indexunix{diff}, but you could
  try \indexunix{tr} to remove the newlines.
\end{exercise}

\lstset{language=C}

%\Level 0 {Unix tools}

%Sed, awk


% LocalWords:  Eijkhout sh ATT Ubuntu csh tcsh ksh zsh Shotts Garrels
% LocalWords:  Machtelt ls cp mv rm ted backquotes
