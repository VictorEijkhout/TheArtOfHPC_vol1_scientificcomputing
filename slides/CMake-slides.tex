% -*- latex -*-
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%
%%%% This text file is part of the source of slides for
%%%% `The Art of HPC, vol 1: The Science of Computing'
%%%% by Victor Eijkhout, copyright 2012-2024
%%%%
%%%% CMake-slides.tex : cmake slides
%%%% see hpc_cmake.tex for driver file
%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\lstset{language=bash}

\subsectionframe{Using a cmake-based library}

\begin{numberedframe}{What are we talking here?}
  \begin{itemize}
  \item You have downloaded a library
  \item It contains a file \n{CMakeLists.txt}
  \item $\Rightarrow$ you need to install it with CMake.
  \item \ldots~and then figure out how to use it in your code.
  \end{itemize}
\end{numberedframe}

\begin{comment}
\begin{numberedframe}{Building software the old way}
  Using `GNU Autotools':
\begin{lstlisting}
./configure
make
make install
\end{lstlisting}
\end{numberedframe}

\begin{numberedframe}{User vs system packages}
  The \n{make install} often tries to copy
  to a system directory. If you're not the admin, do:
\begin{lstlisting}
./configure --prefix=/home/yourname/mypackages
\end{lstlisting}
with a location of your choice.
\end{numberedframe}
\end{comment}

\begin{numberedframe}{Building with CMake}
  \begin{itemize}
  \item Use CMake for the configure stage, then make:
\begin{lstlisting}
cmake -D CMAKE_INSTALL_PREFIX=/home/yourname/packages \
    /home/your/software/package ## source location
make
make install
\end{lstlisting}
or
  \item do everything with CMake:
\begin{lstlisting}
cmake ## arguments
cmake --build ## stuff
cmake --install ## stuff
\end{lstlisting}
  \end{itemize}
  We focus on the first option;
  the second one is portable to non-Unix environments.
\end{numberedframe}

\begin{numberedframe}{What does this buy you?}
  \begin{enumerate}
  \item The source directory is untouched
  \item The build directory contains all temporaries
  \item 
    Your install directory (as specified to CMake)
    now contains executables, libraries, headers~etc.

  You can add these to \n{$PATH}, compiler options,
  \n{$LD_LIBRARY_PATH}.\\
  But see later~\ldots
  \end{enumerate}
\end{numberedframe}

\begin{numberedframe}{The build/make cycle}
  CMake creates makefiles;\\
  makefiles ensure minimal required compilation
  \begin{lstlisting}
    cmake           ## make the makefiles
    make            ## compile your project
    emacs onefile.c ## edit
    make            ## minimal recompile
  \end{lstlisting}
  Only if you add (include) files do you rerun CMake.
\end{numberedframe}

\begin{numberedframe}{Directory structure: two options}
  \hbox to \textwidth\bgroup
  \begin{minipage}{.45\textwidth}
    \tikzsetnextfilename{cmake-insource}
    \begin{tikzpicture}[dirtree]
      \node{dir}
      child { node {src} child { node {build} }
      }
      child { node {install} }
      ;
    \end{tikzpicture}
  \end{minipage}
  \hss
  \begin{minipage}{.45\textwidth}
    \tikzsetnextfilename{cmake-outsource}
    \begin{tikzpicture}[dirtree]
      \node{dir}
      child { node {src} }
      child { node {build} }
      child { node {install} }
      ;
    \end{tikzpicture}
  \end{minipage}
  \egroup
  \begin{itemize}
  \item In-source build: pretty common
  \item Out-of-source build: cleaner because never touches the source tree
  \item Some people skip the install step, and use everything from the build directory.
  \end{itemize}
\begin{lstlisting}
\end{lstlisting}
\end{numberedframe}

\begin{numberedframe}{Out-of-source build: preferred}
  \begin{itemize}
  \item Work from a build directory
  \item Specify prefix and location of \n{CMakeLists.txt}
  \end{itemize}
\lstset{numbers=left,numberstyle=\tiny}
\begin{lstlisting}
ls some_package_1.0.0                # we are outside the source
ls some_package_1.0.0/CMakeLists.txt # source contains cmake file
mkdir builddir                       # location for temporaries
cd builddir                          # goto build location
cmake -D CMAKE_INSTALL_PREFIX=../installdir \
      ../some_package_1.0.0          # cmake invocation
make                                 # make all tmp data in build loc
make install                         # move only final products
\end{lstlisting}
\end{numberedframe}

\begin{numberedframe}{Example: eigen}
  Download from\\
  \url{https://eigen.tuxfamily.org/index.php}\\
  and install.
\end{numberedframe}

\begin{numberedframe}{Basic customizations}
  Compiler settings:
\begin{lstlisting}
cmake -D CMAKE_CXX_COMPILER=icpx
\end{lstlisting}
Alternatively:
\begin{lstlisting}
export CXX=icpx
cmake .......
\end{lstlisting}
Many settings can be done on the commandline:
\begin{lstlisting}
    -D BUILD_SHARED_LIBS=ON
\end{lstlisting}
\end{numberedframe}

\begin{numberedframe}{Tracing and logging}
  \begin{itemize}
  \item CMake prints some sort of progress messages.
  \item To see commandlines:
\begin{lstlisting}[language=bash]
cmake -D CMAKE_VERBOSE_MAKEFILE=ON ...
make V=1
\end{lstlisting}
\item CMake leaves behind a log and error file, but these are insufficent:
  \item $\Rightarrow$~use the above verbose mode and capture all output.
  \end{itemize}
\end{numberedframe}
